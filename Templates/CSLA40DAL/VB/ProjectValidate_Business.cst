<%@ CodeTemplate Inherits="CslaTemplateHelperCS" Language="CSharp" TargetLanguage="CSharp" Description="Generates a CSLA ReadOnly Collection." %>
<%@ Property Name="Errors" Type="System.Text.StringBuilder" Optional="false" Category="Options" Description="Allows the template to return errors to master.cst" %>
<%@ Property Name="Warnings" Type="System.Text.StringBuilder" Optional="false" Category="Options" Description="Allows the template to return warnings to master.cst" %>

<%@ Assembly Name="CslaGenerator" %>
<%@ Import Namespace="CslaGenerator" %>
<%@ Import Namespace="CslaGenerator.Metadata" %>
<%@ Import Namespace="CslaGenerator.CodeGen" %>
<%@ Import Namespace="CslaGenerator.Util" %>
<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="System.Collections.Generic" %>
<%@ Import Namespace="System.Reflection" %>
<%@ Assembly Name="System.Core" %>
<%@ Import Namespace="System.Linq" %>
<%
/*
ERRORS
1. suffix for base and extended must be different
2. suffix for base and comment must be different, except if both are empty
3. suffix for extended and comment must be different, except if both are empty
4. Base namespace can not be empty
5. Utilities namespace can not be empty
6. Utilities namespace must be under Base namespace
7. Connection name can not be empty
8. Object namespace must be under base namespace
WARNINGS
9. When separate namespaces in folders, ignored Utility classes folder
10. Check no repeated object names
11. Check no repeated file names
12. Check no repeated criteria names for non nested class (with more than one property)
*/

if (CurrentUnit.GenerationParams.BaseFilenameSuffix ==
    CurrentUnit.GenerationParams.ExtendedFilenameSuffix)
{
    Errors.Append("Generation settings: 'Suffix for base files' can not be equal to 'Suffix for extended files' (" +
        CurrentUnit.GenerationParams.BaseFilenameSuffix + ")." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.BaseFilenameSuffix != string.Empty &&
    CurrentUnit.GenerationParams.BaseFilenameSuffix ==
    CurrentUnit.GenerationParams.ClassCommentFilenameSuffix)
{
    Errors.Append("Generation settings: 'Suffix for base files' can not be equal to 'Suffix for class comment files' (" +
        CurrentUnit.GenerationParams.BaseFilenameSuffix + ")." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.ExtendedFilenameSuffix != string.Empty &&
    CurrentUnit.GenerationParams.ExtendedFilenameSuffix ==
    CurrentUnit.GenerationParams.ClassCommentFilenameSuffix)
{
    Errors.Append("Generation settings: 'Suffix for extended files' can not be equal to suffix for class comment files (" +
        CurrentUnit.GenerationParams.ExtendedFilenameSuffix + ")." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.BaseNamespace.Equals(string.Empty))
{
    Errors.Append("Generation settings: 'Base namespace' can not be empty." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.UtilitiesNamespace.Equals(string.Empty))
{
    Errors.Append("Generation settings: 'Utility classes namespace' can not be empty." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.UtilitiesNamespace.IndexOf(CurrentUnit.GenerationParams.BaseNamespace) != 0)
{
    Errors.Append("Generation settings: 'Utility classes namespace' (" + CurrentUnit.GenerationParams.UtilitiesNamespace + ") must be under must be under 'Base namespace' (" +
            CurrentUnit.GenerationParams.BaseNamespace + ")." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.DatabaseConnection.Equals(string.Empty))
{
    Errors.Append("Generation settings: 'Connection name' can not be empty." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.SeparateNamespaces &&
    CurrentUnit.GenerationParams.UtilitiesFolder != string.Empty)
{
    Warnings.Append("Generation settings: 'Utility classes folder' will be ignored (separate namespaces in folders is set)." + Environment.NewLine);
}
if (CurrentUnit.GenerationParams.SeparateClassComment &&
    CurrentUnit.GenerationParams.ClassCommentFilenameSuffix == string.Empty)
{
    Warnings.Append("Generation settings: 'Separate class comments in a folder' will be ignored (class comment suffix is empty)." + Environment.NewLine);
}
if (Errors.Length > 0)
    return;

List<string> objectNames = new List<string>();
List<string> filenames = new List<string>();
List<string> criteriaNames = new List<string>();
foreach (CslaObjectInfo objectInfo in CurrentUnit.CslaObjects)
{
    if (objectInfo.Generate)
    {
        if (objectInfo.ObjectNamespace.IndexOf(CurrentUnit.GenerationParams.BaseNamespace) != 0)
        {
            Errors.Append(objectInfo.ObjectName + ": object namespace (" + objectInfo.ObjectNamespace + ") must be under 'Base namespace' (" +
            CurrentUnit.GenerationParams.BaseNamespace + ")." + Environment.NewLine);
        }
        // duplicated object names
        if (objectNames.Contains(objectInfo.ObjectName))
        {
            Warnings.Append(objectInfo.ObjectName + ": object name is repeated." + Environment.NewLine);
        }
        else
        {
            objectNames.Add(objectInfo.ObjectName);
        }
        // duplicated filenames
        if (filenames.Contains(objectInfo.FileName))
        {
            Warnings.Append(objectInfo.ObjectName + ": object file name (" + objectInfo.FileName +
                            ") is repeated." + Environment.NewLine);
        }
        else
        {
            filenames.Add(objectInfo.FileName);
        }
        // duplicated criteria names
        foreach (Criteria criteria in objectInfo.CriteriaObjects)
        {
            if (!criteria.NestedClass && criteria.Properties.Count > 1)
            {
                if (criteriaNames.Contains(criteria.Name))
                {
                    Warnings.Append(objectInfo.ObjectName + ": criteria name (" + criteria.Name +
                            ") is repeated." + Environment.NewLine);
                }
                else
                {
                    criteriaNames.Add(criteria.Name);
                }
            }
        }
    }
}

if (Errors.Length > 0)
    return;
%>